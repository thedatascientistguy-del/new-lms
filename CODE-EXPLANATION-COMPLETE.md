# üìö Complete Code Explanation - Library Management System

## Table of Contents
1. [Project Overview](#project-overview)
2. [Architecture](#architecture)
3. [Core Layer](#core-layer)
4. [Infrastructure Layer](#infrastructure-layer)
5. [API Layer](#api-layer)
6. [Request Flow](#request-flow)
7. [Security Implementation](#security-implementation)

---

## 1. Project Overview

### What This Application Does:
- Users can **signup** and **login**
- Users can **add books** to their library
- Users can **view all their books**
- Users can **view a specific book**
- Users can **delete books**
- Each user can only see their own books (data isolation)

### Technology Stack:
- **.NET 6** - Framework
- **ASP.NET Core Web API** - API framework
- **Dapper** - Database access (micro ORM)
- **SQL Server** - Database
- **AES Encryption** - OS-based encryption
- **Custom Token System** - Fully encrypted authentication tokens

---

## 2. Architecture

### Project Structure:
```
LibraryManagementSystem/
‚îú‚îÄ‚îÄ LibraryManagement.Core/         # Domain layer (entities, interfaces, DTOs)
‚îú‚îÄ‚îÄ LibraryManagement.Infrastructure/ # Data access & services
‚îî‚îÄ‚îÄ LibraryManagement.API/          # Web API (controllers, middleware)
```

### Architecture Pattern: **Clean Architecture**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         API Layer (Controllers)         ‚îÇ
‚îÇ  - AuthController                       ‚îÇ
‚îÇ  - BooksController                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ depends on
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Core Layer (Domain)                ‚îÇ
‚îÇ  - Entities (User, Book)                ‚îÇ
‚îÇ  - DTOs (Request/Response models)       ‚îÇ
‚îÇ  - Interfaces (Contracts)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ implements
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Infrastructure Layer (Data Access)    ‚îÇ
‚îÇ  - Repositories (Dapper)                ‚îÇ
‚îÇ  - Services (JWT, Encryption)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 3. Core Layer

### Purpose:
Contains the **domain models**, **data transfer objects**, and **interfaces**. No dependencies on other layers.


### 3.1 Entities

#### User.cs
```csharp
public class User
{
    public int Id { get; set; }           // Primary key
    public string Username { get; set; }   // Display name
    public string Email { get; set; }      // Login identifier (unique)
    public string PasswordHash { get; set; } // Hashed password (SHA256)
    public DateTime CreatedAt { get; set; } // Registration timestamp
}
```

**Purpose:** Represents a user in the system.

**Key Points:**
- `Id` is auto-generated by database
- `Email` is unique (enforced by database)
- `PasswordHash` stores SHA256 hash, never plain password
- `CreatedAt` tracks when user registered

---

#### Book.cs
```csharp
public class Book
{
    public int Id { get; set; }           // Primary key
    public string Title { get; set; }      // Book title
    public string Author { get; set; }     // Book author
    public string ISBN { get; set; }       // Book ISBN
    public int PublishedYear { get; set; } // Publication year
    public int UserId { get; set; }        // Foreign key to User
    public DateTime CreatedAt { get; set; } // When book was added
}
```

**Purpose:** Represents a book in a user's library.

**Key Points:**
- `UserId` links book to owner (foreign key)
- Each book belongs to exactly one user
- `CreatedAt` tracks when book was added to library

---

### 3.2 DTOs (Data Transfer Objects)

#### SignupRequest.cs
```csharp
public class SignupRequest
{
    public string Username { get; set; }
    public string Email { get; set; }
    public string Password { get; set; }
}
```

**Purpose:** Receives signup data from client.

**Used in:** `POST /api/auth/signup`

---

#### LoginRequest.cs
```csharp
public class LoginRequest
{
    public string Email { get; set; }
    public string Password { get; set; }
}
```

**Purpose:** Receives login credentials from client.

**Used in:** `POST /api/auth/login`

---

#### AuthResponse.cs
```csharp
public class AuthResponse
{
    public int UserId { get; set; }
    public string Token { get; set; }
    public string Username { get; set; }
}
```

**Purpose:** Returns authentication result to client.

**Contains:**
- `UserId` - User's ID
- `Token` - Encrypted authentication token
- `Username` - User's display name

**Used in:** Response from signup and login

---

#### BookRequest.cs
```csharp
public class BookRequest
{
    public string Title { get; set; }
    public string Author { get; set; }
    public string ISBN { get; set; }
    public int PublishedYear { get; set; }
}
```

**Purpose:** Receives book data from client when adding a book.

**Used in:** `POST /api/books`

---

### 3.3 Interfaces

#### IUserRepository.cs
```csharp
public interface IUserRepository
{
    Task<User> GetByEmailAsync(string email);
    Task<User> GetByIdAsync(int id);
    Task<int> CreateAsync(User user);
}
```

**Purpose:** Contract for user data access.

**Methods:**
- `GetByEmailAsync` - Find user by email (for login)
- `GetByIdAsync` - Find user by ID
- `CreateAsync` - Create new user (returns new user ID)

---

#### IBookRepository.cs
```csharp
public interface IBookRepository
{
    Task<Book> GetByIdAsync(int id, int userId);
    Task<IEnumerable<Book>> GetAllAsync(int userId);
    Task<int> CreateAsync(Book book);
    Task<bool> DeleteAsync(int id, int userId);
}
```

**Purpose:** Contract for book data access.

**Methods:**
- `GetByIdAsync` - Get specific book (must belong to user)
- `GetAllAsync` - Get all books for a user
- `CreateAsync` - Add new book (returns new book ID)
- `DeleteAsync` - Delete book (must belong to user)

**Note:** All methods include `userId` for data isolation.

---

#### IJwtService.cs
```csharp
public interface IJwtService
{
    string GenerateToken(int userId, string email);
    int? ValidateToken(string token);
}
```

**Purpose:** Contract for token generation and validation.

**Methods:**
- `GenerateToken` - Create encrypted token for user
- `ValidateToken` - Decrypt and validate token, return userId

---

#### IEncryptionService.cs
```csharp
public interface IEncryptionService
{
    string Encrypt(string plainText);
    string Decrypt(string cipherText);
}
```

**Purpose:** Contract for encryption/decryption.

**Methods:**
- `Encrypt` - Encrypt plain text using AES
- `Decrypt` - Decrypt cipher text using AES

---

## 4. Infrastructure Layer

### Purpose:
Implements the interfaces defined in Core layer. Contains actual data access and business logic.


### 4.1 Repositories

#### UserRepository.cs

**Purpose:** Handles all database operations for users using Dapper.

**Key Methods:**

```csharp
public async Task<User> GetByEmailAsync(string email)
{
    var sql = "SELECT * FROM Users WHERE Email = @Email";
    return await _connection.QueryFirstOrDefaultAsync<User>(sql, new { Email = email });
}
```
- Finds user by email
- Used during login
- Returns `null` if not found

```csharp
public async Task<int> CreateAsync(User user)
{
    var sql = @"INSERT INTO Users (Username, Email, PasswordHash, CreatedAt) 
               VALUES (@Username, @Email, @PasswordHash, @CreatedAt);
               SELECT CAST(SCOPE_IDENTITY() as int)";
    return await _connection.ExecuteScalarAsync<int>(sql, user);
}
```
- Creates new user in database
- Returns the new user's ID
- `SCOPE_IDENTITY()` gets the auto-generated ID

**How Dapper Works:**
- `QueryFirstOrDefaultAsync<User>` - Executes query, maps result to User object
- `ExecuteScalarAsync<int>` - Executes query, returns single value (the new ID)
- `@Email`, `@Username` - Parameterized queries (prevents SQL injection)

---

#### BookRepository.cs

**Purpose:** Handles all database operations for books using Dapper.

**Key Methods:**

```csharp
public async Task<IEnumerable<Book>> GetAllAsync(int userId)
{
    var sql = "SELECT * FROM Books WHERE UserId = @UserId ORDER BY CreatedAt DESC";
    return await _connection.QueryAsync<Book>(sql, new { UserId = userId });
}
```
- Gets all books for a specific user
- Ordered by newest first
- **Data isolation:** Only returns books where `UserId` matches

```csharp
public async Task<Book> GetByIdAsync(int id, int userId)
{
    var sql = "SELECT * FROM Books WHERE Id = @Id AND UserId = @UserId";
    return await _connection.QueryFirstOrDefaultAsync<Book>(sql, new { Id = id, UserId = userId });
}
```
- Gets specific book
- **Security:** Checks both `Id` AND `UserId`
- User can only get their own books

```csharp
public async Task<int> CreateAsync(Book book)
{
    var sql = @"INSERT INTO Books (Title, Author, ISBN, PublishedYear, UserId, CreatedAt) 
               VALUES (@Title, @Author, @ISBN, @PublishedYear, @UserId, @CreatedAt);
               SELECT CAST(SCOPE_IDENTITY() as int)";
    return await _connection.ExecuteScalarAsync<int>(sql, book);
}
```
- Creates new book
- Returns new book ID
- `UserId` is set by controller (from token)

```csharp
public async Task<bool> DeleteAsync(int id, int userId)
{
    var sql = "DELETE FROM Books WHERE Id = @Id AND UserId = @UserId";
    var rowsAffected = await _connection.ExecuteAsync(sql, new { Id = id, UserId = userId });
    return rowsAffected > 0;
}
```
- Deletes book
- **Security:** Checks both `Id` AND `UserId`
- Returns `true` if deleted, `false` if not found

---

### 4.2 Services

#### EncryptionService.cs

**Purpose:** Provides OS-based AES encryption/decryption.

**How It Works:**

```csharp
public EncryptionService()
{
    // Generate machine-specific key
    var entropy = GetMachineEntropy();
    using var sha256 = SHA256.Create();
    var hash = sha256.ComputeHash(entropy);
    _key = hash;              // 32 bytes for AES-256
    _iv = hash.Take(16).ToArray(); // 16 bytes for IV
}

private byte[] GetMachineEntropy()
{
    var machineName = Environment.MachineName;
    var osVersion = Environment.OSVersion.ToString();
    var entropy = $"{machineName}_{osVersion}_LibraryManagement";
    return Encoding.UTF8.GetBytes(entropy);
}
```

**Key Points:**
- Uses **machine name** and **OS version** to generate encryption key
- Same machine = same key
- Different machine = different key
- **AES-256** encryption algorithm
- **SHA256** to derive key from entropy

```csharp
public string Encrypt(string plainText)
{
    using var aes = Aes.Create();
    aes.Key = _key;
    aes.IV = _iv;
    
    var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
    using var ms = new MemoryStream();
    using var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write);
    using (var sw = new StreamWriter(cs))
    {
        sw.Write(plainText);
    }
    return Convert.ToBase64String(ms.ToArray());
}
```

**Encryption Process:**
1. Create AES encryptor with key and IV
2. Write plain text through CryptoStream
3. Convert encrypted bytes to Base64 string
4. Return Base64 string

```csharp
public string Decrypt(string cipherText)
{
    using var aes = Aes.Create();
    aes.Key = _key;
    aes.IV = _iv;
    
    var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
    using var ms = new MemoryStream(Convert.FromBase64String(cipherText));
    using var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);
    using var sr = new StreamReader(cs);
    return sr.ReadToEnd();
}
```

**Decryption Process:**
1. Convert Base64 string to bytes
2. Create AES decryptor with key and IV
3. Read through CryptoStream
4. Return decrypted plain text

---

#### JwtService.cs

**Purpose:** Generates and validates fully encrypted authentication tokens.

**Token Generation:**

```csharp
public string GenerateToken(int userId, string email)
{
    // Create payload with ALL claims
    var payload = new
    {
        uid = userId,
        eml = email,
        jti = Guid.NewGuid().ToString(),
        nbf = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        exp = DateTimeOffset.UtcNow.AddHours(24).ToUnixTimeSeconds(),
        iat = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
        iss = _issuer,
        aud = _audience
    };
    
    // Serialize to JSON
    var payloadJson = JsonSerializer.Serialize(payload);
    
    // Encrypt entire JSON
    var encryptedPayload = _encryptionService.Encrypt(payloadJson);
    
    // Return encrypted string (not JWT format!)
    return encryptedPayload;
}
```

**What Gets Encrypted:**
- `uid` - User ID
- `eml` - Email
- `jti` - Unique token ID (prevents replay attacks)
- `nbf` - Not Before timestamp
- `exp` - Expiration timestamp (24 hours)
- `iat` - Issued At timestamp
- `iss` - Issuer (LibraryManagementAPI)
- `aud` - Audience (LibraryManagementClient)

**Result:** Pure encrypted string with NO visible structure!


**Token Validation:**

```csharp
public int? ValidateToken(string token)
{
    try
    {
        // Decrypt the token
        var decryptedJson = _encryptionService.Decrypt(token);
        
        // Parse JSON
        var payloadDoc = JsonDocument.Parse(decryptedJson);
        var userId = payloadDoc.RootElement.GetProperty("uid").GetInt32();
        
        // Validate expiration
        var exp = payloadDoc.RootElement.GetProperty("exp").GetInt64();
        var expDateTime = DateTimeOffset.FromUnixTimeSeconds(exp).UtcDateTime;
        
        if (expDateTime < DateTime.UtcNow)
            return null; // Token expired
        
        // Validate issuer
        var iss = payloadDoc.RootElement.GetProperty("iss").GetString();
        if (iss != _issuer)
            return null;
        
        // Validate audience
        var aud = payloadDoc.RootElement.GetProperty("aud").GetString();
        if (aud != _audience)
            return null;
        
        return userId;
    }
    catch
    {
        return null; // Invalid token
    }
}
```

**Validation Steps:**
1. Decrypt the token
2. Parse JSON
3. Extract user ID
4. Check if expired
5. Validate issuer
6. Validate audience
7. Return user ID if valid, `null` if invalid

---

## 5. API Layer

### Purpose:
Handles HTTP requests, contains controllers and middleware.

### 5.1 Controllers

#### AuthController.cs

**Purpose:** Handles user authentication (signup and login).

**Signup Endpoint:**

```csharp
[HttpPost("signup")]
public async Task<IActionResult> Signup([FromBody] SignupRequest request)
{
    // 1. Validate input
    if (string.IsNullOrEmpty(request.Email) || string.IsNullOrEmpty(request.Password))
        return BadRequest("Email and password are required");
    
    // 2. Check if user already exists
    var existingUser = await _userRepository.GetByEmailAsync(request.Email);
    if (existingUser != null)
        return BadRequest("User already exists");
    
    // 3. Create user object
    var user = new User
    {
        Username = request.Username,
        Email = request.Email,
        PasswordHash = HashPassword(request.Password), // Hash password
        CreatedAt = DateTime.UtcNow
    };
    
    // 4. Save to database
    var userId = await _userRepository.CreateAsync(user);
    
    // 5. Generate token
    var token = _jwtService.GenerateToken(userId, user.Email);
    
    // 6. Return response
    return Ok(new AuthResponse
    {
        UserId = userId,
        Token = token,
        Username = user.Username
    });
}
```

**Flow:**
1. Validate email and password are provided
2. Check if email already exists
3. Hash password (SHA256)
4. Save user to database
5. Generate encrypted token
6. Return user ID, token, and username

**Why generate token at signup?**
- User is immediately logged in after registration
- Better user experience (no need to login again)
- Industry standard (Twitter, Facebook, etc. all do this)

---

**Login Endpoint:**

```csharp
[HttpPost("login")]
public async Task<IActionResult> Login([FromBody] LoginRequest request)
{
    // 1. Validate input
    if (string.IsNullOrEmpty(request.Email) || string.IsNullOrEmpty(request.Password))
        return BadRequest("Email and password are required");
    
    // 2. Find user by email
    var user = await _userRepository.GetByEmailAsync(request.Email);
    
    // 3. Verify password
    if (user == null || !VerifyPassword(request.Password, user.PasswordHash))
        return Unauthorized("Invalid credentials");
    
    // 4. Generate token
    var token = _jwtService.GenerateToken(user.Id, user.Email);
    
    // 5. Return response
    return Ok(new AuthResponse
    {
        UserId = user.Id,
        Token = token,
        Username = user.Username
    });
}
```

**Flow:**
1. Validate email and password are provided
2. Find user by email
3. Verify password hash matches
4. Generate encrypted token
5. Return user ID, token, and username

---

**Password Hashing:**

```csharp
private string HashPassword(string password)
{
    using var sha256 = SHA256.Create();
    var bytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));
    return Convert.ToBase64String(bytes);
}

private bool VerifyPassword(string password, string hash)
{
    return HashPassword(password) == hash;
}
```

**How it works:**
- SHA256 hashes the password
- Converts hash to Base64 string
- Stores Base64 string in database
- To verify: hash input password and compare

**Security:**
- Passwords never stored in plain text
- One-way hash (can't reverse)
- Same password always produces same hash

---

#### BooksController.cs

**Purpose:** Handles all book operations (CRUD).

**Important:** All methods require authentication (enforced by middleware).

**Get All Books:**

```csharp
[HttpGet]
public async Task<IActionResult> GetAll()
{
    // 1. Get userId from token (set by middleware)
    var userId = GetUserId();
    
    // 2. Get all books for this user
    var books = await _bookRepository.GetAllAsync(userId);
    
    // 3. Return books
    return Ok(books);
}

private int GetUserId()
{
    return (int)HttpContext.Items["UserId"];
}
```

**Flow:**
1. Middleware validates token and stores userId in HttpContext
2. Controller gets userId from HttpContext
3. Repository fetches only books for this user
4. Returns books

**Data Isolation:** User only sees their own books!

---

**Get Book by ID:**

```csharp
[HttpGet("{id}")]
public async Task<IActionResult> GetById(int id)
{
    var userId = GetUserId();
    var book = await _bookRepository.GetByIdAsync(id, userId);
    
    if (book == null)
        return NotFound("Book not found");
    
    return Ok(book);
}
```

**Security:** Repository checks both book ID and user ID.

---

**Create Book:**

```csharp
[HttpPost]
public async Task<IActionResult> Create([FromBody] BookRequest request)
{
    var userId = GetUserId();
    
    var book = new Book
    {
        Title = request.Title,
        Author = request.Author,
        ISBN = request.ISBN,
        PublishedYear = request.PublishedYear,
        UserId = userId,  // Set from token
        CreatedAt = DateTime.UtcNow
    };
    
    var bookId = await _bookRepository.CreateAsync(book);
    book.Id = bookId;
    
    return CreatedAtAction(nameof(GetById), new { id = bookId }, book);
}
```

**Flow:**
1. Get userId from token
2. Create book object with userId
3. Save to database
4. Return created book with 201 status

---

**Delete Book:**

```csharp
[HttpDelete("{id}")]
public async Task<IActionResult> Delete(int id)
{
    var userId = GetUserId();
    var deleted = await _bookRepository.DeleteAsync(id, userId);
    
    if (!deleted)
        return NotFound("Book not found");
    
    return Ok(new { message = "Book deleted successfully" });
}
```

**Security:** Repository checks both book ID and user ID before deleting.

---

### 5.2 Middleware

Middleware runs in order for every request. Think of it as a pipeline.


#### ExceptionHandlingMiddleware.cs

**Purpose:** Catches all unhandled exceptions and returns a friendly error response.

```csharp
public async Task InvokeAsync(HttpContext context)
{
    try
    {
        await _next(context); // Call next middleware
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "An unhandled exception occurred");
        await HandleExceptionAsync(context, ex);
    }
}

private static Task HandleExceptionAsync(HttpContext context, Exception exception)
{
    context.Response.ContentType = "application/json";
    context.Response.StatusCode = 500;
    
    var response = new
    {
        StatusCode = 500,
        Message = "An error occurred while processing your request",
        Detailed = exception.Message
    };
    
    return context.Response.WriteAsync(JsonSerializer.Serialize(response));
}
```

**What it does:**
- Wraps entire request in try-catch
- If any exception occurs, catches it
- Logs the error
- Returns 500 status with error message
- Prevents application crash

**Example:**
```
Database connection fails
    ‚Üì
Exception thrown
    ‚Üì
Middleware catches it
    ‚Üì
Returns: { "statusCode": 500, "message": "An error occurred..." }
```

---

#### DecryptionMiddleware.cs

**Purpose:** Decrypts encrypted request payloads (for POST/PUT requests).

```csharp
public async Task InvokeAsync(HttpContext context)
{
    if (context.Request.Method == "POST" || context.Request.Method == "PUT")
    {
        context.Request.EnableBuffering();
        
        using var reader = new StreamReader(context.Request.Body, Encoding.UTF8, leaveOpen: true);
        var body = await reader.ReadToEndAsync();
        
        if (!string.IsNullOrEmpty(body))
        {
            // Check if body is JSON or encrypted
            var trimmedBody = body.TrimStart();
            bool isJson = trimmedBody.StartsWith("{") || trimmedBody.StartsWith("[");
            
            if (isJson)
            {
                // Already JSON, no decryption needed
                context.Request.Body.Position = 0;
            }
            else
            {
                // Encrypted, decrypt it
                try
                {
                    var decryptedBody = _encryptionService.Decrypt(body);
                    var bytes = Encoding.UTF8.GetBytes(decryptedBody);
                    context.Request.Body = new MemoryStream(bytes);
                    context.Request.Body.Position = 0;
                }
                catch
                {
                    context.Response.StatusCode = 400;
                    await context.Response.WriteAsync("Invalid encrypted payload");
                    return;
                }
            }
        }
    }
    
    await _next(context);
}
```

**What it does:**
- Checks if request is POST or PUT
- Reads request body
- Detects if body is JSON or encrypted
- If JSON: passes through
- If encrypted: decrypts it
- Controller receives decrypted JSON

**Smart Detection:**
- Checks if body starts with `{` or `[` (JSON)
- If yes: it's plain JSON
- If no: it's encrypted, decrypt it

**Why?**
- Allows both plain JSON (for testing) and encrypted payloads
- Flexible for development and production

---

#### JwtValidationMiddleware.cs

**Purpose:** Validates authentication token on every request (except auth endpoints).

```csharp
public async Task InvokeAsync(HttpContext context, IJwtService jwtService)
{
    var path = context.Request.Path.Value?.ToLower();
    
    // Skip validation for auth endpoints
    if (path != null && path.Contains("/auth/"))
    {
        await _next(context);
        return;
    }
    
    // Extract token from Authorization header
    var token = context.Request.Headers["Authorization"]
        .FirstOrDefault()?.Split(" ").Last();
    
    // Check if token exists
    if (string.IsNullOrEmpty(token))
    {
        context.Response.StatusCode = 401;
        await context.Response.WriteAsync("Unauthorized: Token missing");
        return;
    }
    
    // Validate token
    var userId = jwtService.ValidateToken(token);
    
    if (!userId.HasValue)
    {
        context.Response.StatusCode = 401;
        await context.Response.WriteAsync("Unauthorized: Invalid token");
        return;
    }
    
    // Store userId for controllers to use
    context.Items["UserId"] = userId.Value;
    
    await _next(context);
}
```

**Flow:**
1. Check if path is `/auth/` (signup/login)
   - If yes: skip validation (public endpoints)
   - If no: continue validation
2. Extract token from `Authorization: Bearer TOKEN` header
3. Check if token exists
   - If no: return 401 Unauthorized
4. Validate token (decrypt, check expiration, etc.)
   - If invalid: return 401 Unauthorized
5. Store userId in HttpContext
6. Continue to controller

**Result:**
- All `/api/books` endpoints require valid token
- Controllers can access userId via `HttpContext.Items["UserId"]`
- Invalid/missing tokens are rejected

---

### 5.3 Program.cs

**Purpose:** Application startup and configuration.

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(/* Swagger config */);

// Database connection
builder.Services.AddScoped<IDbConnection>(_ =>
    new SqlConnection(builder.Configuration.GetConnectionString("DefaultConnection")));

// Repositories
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IBookRepository, BookRepository>();

// Services
builder.Services.AddSingleton<IEncryptionService, EncryptionService>();
builder.Services.AddSingleton<IJwtService>(sp =>
{
    var encryptionService = sp.GetRequiredService<IEncryptionService>();
    return new JwtService(
        builder.Configuration["Jwt:SecretKey"],
        builder.Configuration["Jwt:Issuer"],
        builder.Configuration["Jwt:Audience"],
        encryptionService
    );
});

var app = builder.Build();

// Middleware pipeline (ORDER MATTERS!)
app.UseMiddleware<ExceptionHandlingMiddleware>();  // 1. Catch exceptions
app.UseMiddleware<DecryptionMiddleware>();         // 2. Decrypt payloads
app.UseHttpsRedirection();                         // 3. Force HTTPS
app.UseMiddleware<JwtValidationMiddleware>();      // 4. Validate tokens
app.MapControllers();                              // 5. Route to controllers

app.Run();
```

**Dependency Injection:**
- `AddScoped` - New instance per request (repositories)
- `AddSingleton` - Single instance for entire app (services)

**Middleware Order:**
```
Request
    ‚Üì
1. ExceptionHandlingMiddleware (wraps everything in try-catch)
    ‚Üì
2. DecryptionMiddleware (decrypts request body if encrypted)
    ‚Üì
3. HTTPS Redirection (ensures secure connection)
    ‚Üì
4. JwtValidationMiddleware (validates token, extracts userId)
    ‚Üì
5. Controller (processes request)
    ‚Üì
Response
```

---

## 6. Request Flow

### 6.1 Signup Flow

```
Client: POST /api/auth/signup
{
  "username": "john",
  "email": "john@example.com",
  "password": "Pass123"
}
    ‚Üì
ExceptionHandlingMiddleware (wraps in try-catch)
    ‚Üì
DecryptionMiddleware (checks if encrypted, decrypts if needed)
    ‚Üì
JwtValidationMiddleware (skips - /auth/ endpoint)
    ‚Üì
AuthController.Signup()
    ‚îú‚îÄ‚ñ∫ Validate input
    ‚îú‚îÄ‚ñ∫ Check if email exists (UserRepository.GetByEmailAsync)
    ‚îú‚îÄ‚ñ∫ Hash password (SHA256)
    ‚îú‚îÄ‚ñ∫ Create user (UserRepository.CreateAsync)
    ‚îÇ   ‚îî‚îÄ‚ñ∫ SQL: INSERT INTO Users... (Dapper)
    ‚îÇ       ‚îî‚îÄ‚ñ∫ Returns userId = 1
    ‚îú‚îÄ‚ñ∫ Generate token (JwtService.GenerateToken)
    ‚îÇ   ‚îú‚îÄ‚ñ∫ Create JSON payload with all claims
    ‚îÇ   ‚îú‚îÄ‚ñ∫ Encrypt entire JSON (EncryptionService.Encrypt)
    ‚îÇ   ‚îî‚îÄ‚ñ∫ Returns encrypted string
    ‚îî‚îÄ‚ñ∫ Return response
    ‚Üì
Response: 200 OK
{
  "userId": 1,
  "token": "Y6s9iiF8t98B1TQ7hP+s9ilJs1XkrIwHZlIUTV91uTRt...",
  "username": "john"
}
```

---

### 6.2 Login Flow

```
Client: POST /api/auth/login
{
  "email": "john@example.com",
  "password": "Pass123"
}
    ‚Üì
ExceptionHandlingMiddleware
    ‚Üì
DecryptionMiddleware
    ‚Üì
JwtValidationMiddleware (skips - /auth/ endpoint)
    ‚Üì
AuthController.Login()
    ‚îú‚îÄ‚ñ∫ Validate input
    ‚îú‚îÄ‚ñ∫ Find user (UserRepository.GetByEmailAsync)
    ‚îÇ   ‚îî‚îÄ‚ñ∫ SQL: SELECT * FROM Users WHERE Email = @Email
    ‚îú‚îÄ‚ñ∫ Verify password hash
    ‚îú‚îÄ‚ñ∫ Generate token (JwtService.GenerateToken)
    ‚îî‚îÄ‚ñ∫ Return response
    ‚Üì
Response: 200 OK
{
  "userId": 1,
  "token": "Y6s9iiF8t98B1TQ7hP+s9ilJs1XkrIwHZlIUTV91uTRt...",
  "username": "john"
}
```


---

### 6.3 Add Book Flow

```
Client: POST /api/books
Authorization: Bearer Y6s9iiF8t98B1TQ7hP+s9ilJs1XkrIwHZlIUTV91uTRt...
{
  "title": "Clean Code",
  "author": "Robert C. Martin",
  "isbn": "978-0132350884",
  "publishedYear": 2008
}
    ‚Üì
ExceptionHandlingMiddleware
    ‚Üì
DecryptionMiddleware (decrypts if encrypted)
    ‚Üì
JwtValidationMiddleware
    ‚îú‚îÄ‚ñ∫ Extract token from Authorization header
    ‚îú‚îÄ‚ñ∫ Validate token (JwtService.ValidateToken)
    ‚îÇ   ‚îú‚îÄ‚ñ∫ Decrypt token (EncryptionService.Decrypt)
    ‚îÇ   ‚îú‚îÄ‚ñ∫ Parse JSON
    ‚îÇ   ‚îú‚îÄ‚ñ∫ Check expiration
    ‚îÇ   ‚îú‚îÄ‚ñ∫ Validate issuer and audience
    ‚îÇ   ‚îî‚îÄ‚ñ∫ Returns userId = 1
    ‚îú‚îÄ‚ñ∫ Store userId in HttpContext.Items["UserId"]
    ‚îî‚îÄ‚ñ∫ Continue to controller
    ‚Üì
BooksController.Create()
    ‚îú‚îÄ‚ñ∫ Get userId from HttpContext.Items["UserId"] = 1
    ‚îú‚îÄ‚ñ∫ Create Book object with userId
    ‚îú‚îÄ‚ñ∫ Save book (BookRepository.CreateAsync)
    ‚îÇ   ‚îî‚îÄ‚ñ∫ SQL: INSERT INTO Books... (Dapper)
    ‚îÇ       ‚îî‚îÄ‚ñ∫ Returns bookId = 5
    ‚îî‚îÄ‚ñ∫ Return created book
    ‚Üì
Response: 201 Created
{
  "id": 5,
  "title": "Clean Code",
  "author": "Robert C. Martin",
  "isbn": "978-0132350884",
  "publishedYear": 2008,
  "userId": 1,
  "createdAt": "2026-01-15T10:30:00Z"
}
```

---

### 6.4 Get All Books Flow

```
Client: GET /api/books
Authorization: Bearer Y6s9iiF8t98B1TQ7hP+s9ilJs1XkrIwHZlIUTV91uTRt...
    ‚Üì
ExceptionHandlingMiddleware
    ‚Üì
DecryptionMiddleware (skips - GET request)
    ‚Üì
JwtValidationMiddleware
    ‚îú‚îÄ‚ñ∫ Validate token
    ‚îú‚îÄ‚ñ∫ Extract userId = 1
    ‚îî‚îÄ‚ñ∫ Store in HttpContext
    ‚Üì
BooksController.GetAll()
    ‚îú‚îÄ‚ñ∫ Get userId = 1 from HttpContext
    ‚îú‚îÄ‚ñ∫ Get books (BookRepository.GetAllAsync(1))
    ‚îÇ   ‚îî‚îÄ‚ñ∫ SQL: SELECT * FROM Books WHERE UserId = 1
    ‚îÇ       ‚îî‚îÄ‚ñ∫ Returns [book1, book2, book3]
    ‚îî‚îÄ‚ñ∫ Return books
    ‚Üì
Response: 200 OK
[
  {
    "id": 5,
    "title": "Clean Code",
    "author": "Robert C. Martin",
    "isbn": "978-0132350884",
    "publishedYear": 2008,
    "userId": 1,
    "createdAt": "2026-01-15T10:30:00Z"
  },
  {
    "id": 6,
    "title": "The Pragmatic Programmer",
    "author": "Andrew Hunt",
    "isbn": "978-0201616224",
    "publishedYear": 1999,
    "userId": 1,
    "createdAt": "2026-01-15T10:35:00Z"
  }
]
```

---

### 6.5 Delete Book Flow

```
Client: DELETE /api/books/5
Authorization: Bearer Y6s9iiF8t98B1TQ7hP+s9ilJs1XkrIwHZlIUTV91uTRt...
    ‚Üì
ExceptionHandlingMiddleware
    ‚Üì
DecryptionMiddleware (skips - DELETE request)
    ‚Üì
JwtValidationMiddleware
    ‚îú‚îÄ‚ñ∫ Validate token
    ‚îú‚îÄ‚ñ∫ Extract userId = 1
    ‚îî‚îÄ‚ñ∫ Store in HttpContext
    ‚Üì
BooksController.Delete(5)
    ‚îú‚îÄ‚ñ∫ Get userId = 1 from HttpContext
    ‚îú‚îÄ‚ñ∫ Delete book (BookRepository.DeleteAsync(5, 1))
    ‚îÇ   ‚îî‚îÄ‚ñ∫ SQL: DELETE FROM Books WHERE Id = 5 AND UserId = 1
    ‚îÇ       ‚îî‚îÄ‚ñ∫ Returns true (1 row affected)
    ‚îî‚îÄ‚ñ∫ Return success message
    ‚Üì
Response: 200 OK
{
  "message": "Book deleted successfully"
}
```

---

### 6.6 Unauthorized Request Flow (No Token)

```
Client: GET /api/books
(No Authorization header)
    ‚Üì
ExceptionHandlingMiddleware
    ‚Üì
DecryptionMiddleware
    ‚Üì
JwtValidationMiddleware
    ‚îú‚îÄ‚ñ∫ Check for token
    ‚îú‚îÄ‚ñ∫ Token not found
    ‚îî‚îÄ‚ñ∫ Return 401 Unauthorized
    ‚Üì
Response: 401 Unauthorized
"Unauthorized: Token missing"
```

---

### 6.7 Invalid Token Flow

```
Client: GET /api/books
Authorization: Bearer invalid_token_here
    ‚Üì
ExceptionHandlingMiddleware
    ‚Üì
DecryptionMiddleware
    ‚Üì
JwtValidationMiddleware
    ‚îú‚îÄ‚ñ∫ Extract token = "invalid_token_here"
    ‚îú‚îÄ‚ñ∫ Validate token (JwtService.ValidateToken)
    ‚îÇ   ‚îú‚îÄ‚ñ∫ Try to decrypt
    ‚îÇ   ‚îî‚îÄ‚ñ∫ Decryption fails (invalid format)
    ‚îú‚îÄ‚ñ∫ Returns null (invalid)
    ‚îî‚îÄ‚ñ∫ Return 401 Unauthorized
    ‚Üì
Response: 401 Unauthorized
"Unauthorized: Invalid token"
```

---

## 7. Security Implementation

### 7.1 Password Security

**How passwords are protected:**

```
User enters password: "MyPassword123"
    ‚Üì
SHA256 hash: "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8"
    ‚Üì
Base64 encode: "XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg="
    ‚Üì
Store in database
```

**Login verification:**
```
User enters password: "MyPassword123"
    ‚Üì
Hash it: "XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg="
    ‚Üì
Compare with stored hash
    ‚Üì
Match? ‚Üí Login successful
No match? ‚Üí Invalid credentials
```

**Why SHA256?**
- One-way hash (can't reverse)
- Same input always produces same output
- Fast to compute
- Secure for password hashing

---

### 7.2 Token Security

**Token Generation:**
```
User data: { userId: 1, email: "john@example.com" }
    ‚Üì
Create JSON with all claims:
{
  "uid": 1,
  "eml": "john@example.com",
  "jti": "unique-id",
  "nbf": 1768463073,
  "exp": 1768549473,
  "iat": 1768463073,
  "iss": "LibraryManagementAPI",
  "aud": "LibraryManagementClient"
}
    ‚Üì
Serialize to JSON string
    ‚Üì
Encrypt with AES-256 (OS-based key)
    ‚Üì
Result: "Y6s9iiF8t98B1TQ7hP+s9ilJs1XkrIwHZlIUTV91uTRt..."
```

**What attackers see:**
```
Y6s9iiF8t98B1TQ7hP+s9ilJs1XkrIwHZlIUTV91uTRt7jYtTZkzDI65gqvPkAIhGkJ6p0GxAqUSa/GBuGiM5+2ha1r9SwxWrhrQ0UW0sbApXgtCF/Xo9BwtPmlNwaSXuQy5Bt/d+F7JlezpU9PMDAYJJIRGNvaa0zaFmZZ4VhZ5LSpDgo0OEXFsdjRqbYK6IO4gPI9LwXK0JELiP/bhkCIKHKptDgAmQIjgGYc2Yor7+Bfl9oV2+ic6vk9tfVl3
```

**They can't:**
- ‚ùå Decode it on jwt.io
- ‚ùå See user ID
- ‚ùå See email
- ‚ùå See expiration
- ‚ùå See any information

**Security features:**
- ‚úÖ AES-256 encryption
- ‚úÖ OS-based key (machine-specific)
- ‚úÖ 24-hour expiration
- ‚úÖ Issuer validation
- ‚úÖ Audience validation
- ‚úÖ Unique token ID (prevents replay)

---

### 7.3 Data Isolation

**How users are isolated:**

```
User 1 (userId = 1) requests books:
    ‚Üì
Token validated ‚Üí userId = 1
    ‚Üì
SQL: SELECT * FROM Books WHERE UserId = 1
    ‚Üì
Returns only User 1's books
```

```
User 2 (userId = 2) requests books:
    ‚Üì
Token validated ‚Üí userId = 2
    ‚Üì
SQL: SELECT * FROM Books WHERE UserId = 2
    ‚Üì
Returns only User 2's books
```

**User 1 tries to access User 2's book:**
```
User 1 token ‚Üí userId = 1
    ‚Üì
GET /api/books/999 (belongs to User 2)
    ‚Üì
SQL: SELECT * FROM Books WHERE Id = 999 AND UserId = 1
    ‚Üì
No results (book belongs to User 2)
    ‚Üì
Returns: 404 Not Found
```

**Security:**
- Every query includes `UserId` filter
- Users can only see/modify their own data
- No way to access other users' data

---

### 7.4 SQL Injection Prevention

**Dapper uses parameterized queries:**

```csharp
// ‚ùå UNSAFE (vulnerable to SQL injection)
var sql = $"SELECT * FROM Users WHERE Email = '{email}'";

// ‚úÖ SAFE (parameterized query)
var sql = "SELECT * FROM Users WHERE Email = @Email";
await _connection.QueryFirstOrDefaultAsync<User>(sql, new { Email = email });
```

**Why parameterized queries are safe:**
```
Attacker input: "admin@example.com' OR '1'='1"
    ‚Üì
Unsafe query: SELECT * FROM Users WHERE Email = 'admin@example.com' OR '1'='1'
    ‚Üì
Result: Returns ALL users (SQL injection!)
```

```
Attacker input: "admin@example.com' OR '1'='1"
    ‚Üì
Safe query: SELECT * FROM Users WHERE Email = @Email
    ‚Üì
Parameter: @Email = "admin@example.com' OR '1'='1"
    ‚Üì
Result: No user found (treated as literal string)
```

---

### 7.5 HTTPS Encryption

**All traffic is encrypted:**
```
Client ‚Üí HTTPS ‚Üí Server
```

**What HTTPS protects:**
- ‚úÖ Request headers (including Authorization token)
- ‚úÖ Request body
- ‚úÖ Response body
- ‚úÖ Prevents man-in-the-middle attacks

---

## 8. Database Schema

### Users Table
```sql
CREATE TABLE Users (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Username NVARCHAR(100) NOT NULL,
    Email NVARCHAR(255) NOT NULL UNIQUE,
    PasswordHash NVARCHAR(500) NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE()
);
```

### Books Table
```sql
CREATE TABLE Books (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Title NVARCHAR(255) NOT NULL,
    Author NVARCHAR(255) NOT NULL,
    ISBN NVARCHAR(50) NOT NULL,
    PublishedYear INT NOT NULL,
    UserId INT NOT NULL,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    FOREIGN KEY (UserId) REFERENCES Users(Id) ON DELETE CASCADE
);

CREATE INDEX IX_Books_UserId ON Books(UserId);
```

**Relationships:**
- One User ‚Üí Many Books
- Books.UserId ‚Üí Users.Id (Foreign Key)
- CASCADE DELETE: When user is deleted, all their books are deleted

---

## 9. Configuration (appsettings.json)

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost\\SQLEXPRESS;Database=LibraryManagementDB;Trusted_Connection=True;TrustServerCertificate=True;"
  },
  "Jwt": {
    "SecretKey": "YourSuperSecretKeyForJWTTokenGeneration123456",
    "Issuer": "LibraryManagementAPI",
    "Audience": "LibraryManagementClient"
  }
}
```

**Settings:**
- `ConnectionStrings.DefaultConnection` - Database connection
- `Jwt.SecretKey` - Used for token validation (not for encryption)
- `Jwt.Issuer` - Token issuer (validated)
- `Jwt.Audience` - Token audience (validated)

---

## 10. Summary

### Key Concepts:

1. **Clean Architecture** - Separation of concerns (Core, Infrastructure, API)
2. **Repository Pattern** - Data access abstraction
3. **Dependency Injection** - Loose coupling
4. **Middleware Pipeline** - Request processing chain
5. **Token-based Authentication** - Stateless authentication
6. **Data Isolation** - Users can only access their own data
7. **Encryption** - OS-based AES encryption for tokens
8. **Password Hashing** - SHA256 for password security

### Security Layers:

1. **HTTPS** - Encrypts all traffic
2. **Password Hashing** - SHA256
3. **Token Encryption** - AES-256 with OS-based keys
4. **Token Validation** - Expiration, issuer, audience checks
5. **Data Isolation** - UserId filtering in all queries
6. **SQL Injection Prevention** - Parameterized queries
7. **Exception Handling** - No sensitive data in errors

### Request Flow Summary:

```
Client Request
    ‚Üì
ExceptionHandlingMiddleware (catch errors)
    ‚Üì
DecryptionMiddleware (decrypt if needed)
    ‚Üì
JwtValidationMiddleware (validate token)
    ‚Üì
Controller (process request)
    ‚Üì
Repository (database access)
    ‚Üì
Response
```

---

## 11. Quick Reference

### API Endpoints:

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| POST | /api/auth/signup | No | Register new user |
| POST | /api/auth/login | No | Login user |
| GET | /api/books | Yes | Get all user's books |
| GET | /api/books/{id} | Yes | Get specific book |
| POST | /api/books | Yes | Add new book |
| DELETE | /api/books/{id} | Yes | Delete book |

### Key Classes:

**Core Layer:**
- `User` - User entity
- `Book` - Book entity
- `SignupRequest`, `LoginRequest`, `BookRequest` - Request DTOs
- `AuthResponse` - Response DTO
- `IUserRepository`, `IBookRepository` - Repository interfaces
- `IJwtService`, `IEncryptionService` - Service interfaces

**Infrastructure Layer:**
- `UserRepository` - User data access (Dapper)
- `BookRepository` - Book data access (Dapper)
- `JwtService` - Token generation/validation
- `EncryptionService` - AES encryption/decryption

**API Layer:**
- `AuthController` - Signup/Login endpoints
- `BooksController` - Book CRUD endpoints
- `ExceptionHandlingMiddleware` - Global error handling
- `DecryptionMiddleware` - Payload decryption
- `JwtValidationMiddleware` - Token validation
- `Program.cs` - Application startup

---

## 12. Troubleshooting

### Common Issues:

**401 Unauthorized:**
- Missing token ‚Üí Add `Authorization: Bearer TOKEN` header
- Invalid token ‚Üí Get new token by logging in
- Expired token ‚Üí Token expires after 24 hours, login again

**404 Not Found:**
- Book doesn't exist
- Book belongs to another user (data isolation)

**400 Bad Request:**
- Invalid input data
- Missing required fields
- Invalid encrypted payload

**500 Internal Server Error:**
- Database connection failed
- Unhandled exception
- Check logs for details

---

**End of Documentation**

This document explains every class, the complete flow, and how all components work together. Use this as a reference to understand the codebase!
